base
====

Serialization
-------------

:py:class:`BLUEPRINT.reactor.Reactor` objects can be serialized and deserialized using
the :py:meth:`BLUEPRINT.reactor.Reactor.save` and :py:meth:`BLUEPRINT.reactor.Reactor.load`
methods. Under the hood they use
`pickle <https://docs.python.org/3/library/pickle.html>`_.

Not all of the attributes of a `Reactor` can be serialized. After loading you may need to
call again the following methods:

* `run_PROCESS`
* `build_neutronics_model`
* `build_cad`

An example of serializing and de-serializing a reactor object to a file:

.. code-block:: pycon

    >>> R = SingleNullReactor(Config, Build_Config, Build_Tweaks)
    >>> R.build()
    >>> R.save('reactor.pkl')
    >>> R2 = SingleNullReactor.load('reactor.pkl')

The `save` method will automatically create a pickle for you if you don't specify a path. `save` returns the path to
the persisted reactor:

.. code-block:: pycon

    >>> R = SingleNullReactor(Config, Build_Config, Build_Tweaks)
    >>> R.build()
    >>> path = R.save()
    >>> R2 = SingleNullReactor.load(path)


.. warning::

    pickle is not a secure protocol and unpickling untrusted objects can result in code execution,
    which is a security vulnerability.

.. note::

    `Reactor` classes are intended to have one instance per class. When a reactor is
    loaded the :py:class:`BLUEPRINT.base.parameter.ParameterFrame` on the reactor class is replaced with the loaded
    one.

    `Reactor` classes are stored in a registry on creation, so every `Reactor` must have a unique name. The right class
    must exist (either having been recreated or imported) before loading.

You can also directly `pickle` and `unpickle` Reactor objects directly:

.. code-block:: pycon

   >>> import pickle
   >>> R = SingleNullReactor(Config, Build_Config, Build_Tweaks)
   >>> R.build()
   >>> with open('reactor.pkl', 'wb') as f:
   ...     pickle.dump(f, reactor)
   ...
   >>> with open('reactor.pkl', 'rb') as f:
   ...     R = pickle.load(f)
   ...
   >>>

Absolute & Relative Paths
-------------------------

`Reactor` class instances have two paths specified in `Build_Config`:

* `reference_data_root` is used to store working data during the run.
* `generated_data_root` is used to store output data generated by the run.

These paths may be absolute, or they may be relative to the BLUEPRINT root folder by prefixing
the keyword ``!BP_ROOT!``. When the `Reactor` class is instantiated, the keyword will
be replaced with the path to BLUEPRINT root for the current system.

For example:

.. code-block:: pycon

    >>> Build_Config = {
            "reference_data_root": "!BP_ROOT!/data",
            "generated_data_root": "!BP_ROOT!/generated_data",
        }

Type-checking
-------------

A type-checking framework is available to help in development. Checks are carried out at runtimes and will raise a :py:class:`BLUEPRINT.typebase.TypeFrameworkError` if the specified types are not those expected.

The framework uses Python annotations and the :py:mod:`typing` module to enforce types.

.. code-block:: python

    from typing import Type, List
    from BLUEPRINT.base.baseclass import ReactorSystem
    from BLUEPRINT.geometry.loop import Loop

    class Example(ReactorSystem):
        a: str
        b: List[float]
        c: Type[Loop]

        def __init__(self, a: str, b: List[float], c: Type[Loop], d: int):
            self.a = a
            self.b = b
            self.c = c
            self.d = d

        def do_something(self, e: float) -> Type[Loop]:
            return self.c.offset(self.b[0]+self.d+e)

If we try to violate these type specifications, we get an error:

.. code-block:: pycon

   >>> E = Example('test', [5.6, 5], Loop([4, 5, 6], [6, 7, 8]), 4)
   >>> BLUEPRINT.base.typebase.TypeFrameworkError: Error in module: __main__
       function: __init__

       was expecting argument 'b'=[5.6, 5] to be of type 'typing.List[float]'

   >>> E = Example('test', [5.6, 5.], Loop([4, 5, 6], [6, 7, 8]), 4)
   ... E.do_something(4)
   >>> BLUEPRINT.base.typebase.TypeFrameworkError: Error in module: __main__
       function: do_something
       was expecting argument 'e'=4 to be of type '<class 'float'>'

The type-checking functionality has a global on/off switch: :py:const:`ENGAGE_TYPECHECKING` in :py:mod:`BLUEPRINT.base.typebase`.

If functions annotations are not used in a function or class, type-checking is not implemented.



