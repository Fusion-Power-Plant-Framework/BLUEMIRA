# bluemira is an integrated inter-disciplinary design tool for future fusion
# reactors. It incorporates several modules, some of which rely on other
# codes, to carry out a range of typical conceptual fusion reactor design
# activities.
#
# Copyright (C) 2021 M. Coleman, J. Cook, F. Franza, I.A. Maione, S. McIntosh, J. Morris,
#                    D. Short
#
# bluemira is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# bluemira is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with bluemira; if not, see <https://www.gnu.org/licenses/>.

"""
Application of the dolfin fem 2D magnetostatic to a single coil problem
"""

# %%[markdown]

# # Introduction

# In this example, we will show how to use the fem_magnetostatic_2D solver to find the
# magnetic field generated by a simple coil. The coil axis is the z-axis. Solution is
# calculated on the xz plane.

# # Imports

# Import necessary module definitions.

# %%

import os

import dolfin
import matplotlib.pyplot as plt
import numpy as np

import bluemira.geometry.tools as tools
from bluemira.base.components import Component, PhysicalComponent
from bluemira.base.file import get_bluemira_root
from bluemira.equilibria.fem_fixed_boundary.fem_magnetostatic_2D import (
    FemMagnetostatic2d,
)
from bluemira.equilibria.fem_fixed_boundary.utilities import ScalarSubFunc, b_coil_axis
from bluemira.geometry.face import BluemiraFace
from bluemira.geometry.placement import BluemiraPlacement
from bluemira.mesh import meshing

HAS_MSH2XDMF = False
try:
    from bluemira.utilities.tools import get_module

    msh2xdmf = get_module(
        os.path.join(get_bluemira_root(), "..", "msh2xdmf", "msh2xdmf.py")
    )

    HAS_MSH2XDMF = True
except ImportError as err:
    print(f"Unable to import msh2xdmf, dolfin examples will not run: {err}")

# %%[markdown]

# # Creation of the geometry

# Definition of coil and enclosure parameters

# %%
r_enclo = 100
lcar_enclo = 0.5

rc = 5
drc = 0.01
lcar_coil = 0.01

# %%[markdown]

# create the coil (rectangular cross section) and set the mesh options
# Note: just to simulate a "real" application, enclosure is generated into the xz
# plane, but then its placement is changed in order to be in the xy plane (due to a
# limitation in the importing of the mesh with msh2xdmf for which only the first 2
# column are considered when importing a 2D mesh)

# %%

poly_coil = tools.make_polygon(
    [[rc - drc, rc + drc, rc + drc, rc - drc], [0, 0, 0, 0], [-drc, -drc, +drc, +drc]],
    closed=True,
    label="poly_enclo",
)
poly_coil.change_placement((BluemiraPlacement(axis=[1.0, 0.0, 0.0], angle=-90)))

poly_coil.mesh_options = {"lcar": lcar_coil, "physical_group": "poly_coil"}
coil = BluemiraFace(poly_coil)
coil.mesh_options = {"lcar": lcar_coil, "physical_group": "coil"}

# %%[markdown]

# create the enclosure (rectangular cross section) and set the mesh options

# %%
poly_enclo = tools.make_polygon(
    [[0, r_enclo, r_enclo, 0], [0, 0, 0, 0], [-r_enclo, -r_enclo, r_enclo, r_enclo]],
    closed=True,
    label="poly_enclo",
)
poly_enclo.change_placement((BluemiraPlacement(axis=[1.0, 0.0, 0.0], angle=-90)))

poly_enclo.mesh_options = {"lcar": lcar_enclo, "physical_group": "poly_enclo"}
enclosure = BluemiraFace([poly_enclo, poly_coil])
enclosure.mesh_options = {"lcar": lcar_enclo, "physical_group": "enclo"}

# %%[markdown]

# create the different components

# %%
c_universe = Component(name="universe")
c_enclo = PhysicalComponent(name="enclosure", shape=enclosure, parent=c_universe)
c_coil = PhysicalComponent(name="coil", shape=coil, parent=c_universe)

# %%[markdown]

# # Mesh

# Create the mesh (by default, mesh is stored in the file Mesh.msh")

# %%

m = meshing.Mesh()
m(c_universe, dim=2)

# %%[markdown]

# Convert the mesh in xdmf for reading in fenics. Note that this requires the msh2xdmf
# module to be available.

# %%

msh2xdmf.msh2xdmf("Mesh.msh", dim=2, directory=".")

mesh, boundaries, subdomains, labels = msh2xdmf.import_mesh(
    prefix="Mesh",
    dim=2,
    directory=".",
    subdomains=True,
)
dolfin.plot(mesh)
plt.show()

# %%[markdown]

# # Setup EM problem

# Finally, instantiate the em solver

# %%

em_solver = FemMagnetostatic2d(mesh, boundaries, p=3)

# %%[markdown]

# Define source term (coil current distribution) for the fem problem

# %%

Ic = 1e6
jc = Ic / coil.area
markers = [labels["coil"]]
functions = [jc]
jtot = ScalarSubFunc(functions, markers, subdomains)

# %%[markdown]

# plot the source term

# %%

f_space = dolfin.FunctionSpace(mesh, "DG", 0)
f = dolfin.Function(f_space)
f.interpolate(jtot)
dolfin.plot(f, title="Source term")
plt.show()

# %%[markdown]

# solve the em problem

# %%

em_solver.solve(jtot)

# %%[markdown]

# compare the obtained B with the theoretical value

# %%
axis = np.linspace(0, r_enclo, 200)
B_axis = np.array([em_solver.B(x) for x in np.array([axis * 0, axis]).T]).T[1]
B_teo = np.array([b_coil_axis(rc, 0, z, Ic) for z in axis])

fig, ax = plt.subplots()
ax.plot(axis, B_axis, label="B_calc")
ax.plot(axis, B_teo, label="B_teo")
plt.legend()
plt.show()

diff = B_axis - B_teo
fig, ax = plt.subplots()
ax.plot(axis, diff)
plt.title("B_calc - B_teo")
plt.show()
