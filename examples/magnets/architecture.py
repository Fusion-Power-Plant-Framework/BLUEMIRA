from bluemira.base.components import PhysicalComponent
from bluemira.geometry.base import BluemiraGeo


class SuperconductingWire(PhysicalComponent):

    # lx, ly
    # max strain?
    # T_marg: temperature margin
    # d_strand: strand diameter
    # d_cu: copper diameter
    # VF: void fraction
    # cos(theta) ?
    # cu_noncu: percentage (Cu:nonCu)
    # N_cu: number of copper conductors
    # N_strand: number of superconductor strands

    def critical_current(self, B, T, eps):
        pass

    def A_cu(self):
        return ...


def B_tf_wp(r, y, n_tf, B_0, R_0, R_k, R_i, R_e):
    """
    Return the field generated by the TF coil system considering the ripple effect
    inside the WP (linear decreasing inside the WP region considering Ampere's law)

    PARAMETERS
    ----------
    r,y: radial and toroidal position of the point
    n_tf: number of toroidal field coils
    B_0, R_0: ...
    R_k: inner-inner radial distance of the WP
    R_i: inner-outer radial distance of the WP
    R_e: outer_inner radial distance of the WP
    """
    # correction factor due to ripple
    f = 1/(R_0/R_i)*(1 + 1/((R_0/R_i)**n_tf - 1) + 1/((R_e/R_0)**n_tf - 1))

    # peak at R_i
    Bt = R_0*B_0/R_i * f

    # min at R_k
    # ...

    # implement linear decrease
    # Bt = ...

    return Bt

# function that calculates the minimum number of nstrans to not exceed the hot spot T critirea
def optimize_nstrand_hot_spot_temp_criteria(...):
    ...

class TFCoil_WP_manager:
    def __init__(
        self,
        n_tf: int,
        case_shape: BluemiraGeo,
        wp_shape: BluemiraGeo,
        B_0: float,
        R_0: float,
        superconductor: SuperconductingWire,
        T_op: float,
    ):

        # INITIAL GUESS

        #calculate operational current for each TFC
        I_op_tf = 2*np.pi*R_0*B_0/(mu_0*n_tf)

        #calculate max magnetic field inside the WP (i.e. at r = R_i)
        ## find a way to get R_i, R_k, R_e from case_shape and wp_shape
        max_b = B_tf_wp(R_i, 0, n_tf, B_0, R_0, R_k, R_i, R_e)



        # Provide initial guess for the superconductor dimensions dx,dy
        # probably direcly in the instance of the superconductor object

        # create a grid and check how many conductors can be placed in the WP
        # this defines n_turns and n_layers
        n_turns = ...
        n_layers = ...

        # Find the operational current for each cable
        # Note: the following implementation would be for the simplified case of
        # a rectangle WP, but it would be useful to find a general approach
        # (maybe using an array that indicate the number of cables for each turn
        # or for each layer)
        I_op_c = I_op_tf/(n_turns * n_layers)

        # Find the critical current for each layer
        # B_layer can be found from the B function inside the WP
        # T_op is given (?)
        # Problem: hoe to initiliaze eps?
        I_clayer = superconductor.critical_current(B_layer, T_op, eps)

        # find nstrand using hot-spot temperature criteria
        nstrand = optimize_nstrand_hot_spot_temp_criteria(...)

        #How to calculate Ncu? Is there a relation between Nstrand and Ncu?

        #### CICC steel ####
        for each layer
            pm =  B_layer/(2*mu_0)
            xi_jacket = fun(dx_jacket, dy_jacket, dx_cond, dy_cond, dx_cable, dy_cable) #see eq 15
            sigma_r = ... # eq 18

        ### Casing steel
        # Process simplified approach? Should we change the casing if we take as reference the
        # Process output?
        t.b.d.
