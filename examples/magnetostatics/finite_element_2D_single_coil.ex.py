# ---
# jupyter:
#   jupytext:
#     cell_metadata_filter: tags,-all
#     notebook_metadata_filter: -jupytext.text_representation.jupytext_version
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% tags=["remove-cell"]
# SPDX-FileCopyrightText: 2021-present M. Coleman, J. Cook, F. Franza
# SPDX-FileCopyrightText: 2021-present I.A. Maione, S. McIntosh
# SPDX-FileCopyrightText: 2021-present J. Morris, D. Short
#
# SPDX-License-Identifier: LGPL-2.1-or-later

"""
Application of the dolfin fem 2D magnetostatic to a single coil problem
"""

# %% [markdown]
# # 2-D FEM magnetostatic single coil
# ## Introduction
#
# In this example, we will show how to use the fem_magnetostatic_2D solver to find the
# magnetic field generated by a simple coil. The coil axis is the z-axis. Solution is
# calculated on the xz plane.
#
# ## Imports
#
# Import necessary module definitions.

# %%
from pathlib import Path

import dolfin
import matplotlib.pyplot as plt
import numpy as np

from bluemira.base.components import Component, PhysicalComponent
from bluemira.base.file import get_bluemira_path
from bluemira.geometry import tools
from bluemira.geometry.face import BluemiraFace
from bluemira.magnetostatics import greens
from bluemira.magnetostatics.finite_element_2d import (
    Bz_coil_axis,
    FemMagnetostatic2d,
    ScalarSubFunc,
)
from bluemira.mesh import meshing
from bluemira.mesh.tools import import_mesh, msh_to_xdmf

# %% [markdown]
#
# ## Creation of the geometry
#
# Definition of coil and enclosure parameters

# %%
r_enclo = 100
lcar_enclo = 1.0

rc = 5
drc = 0.025
lcar_coil = 0.05

# %% [markdown]
#
# create the coil (rectangular cross section) and set the mesh options

# %%
poly_coil = tools.make_polygon(
    [[rc - drc, rc + drc, rc + drc, rc - drc], [0, 0, 0, 0], [-drc, -drc, +drc, +drc]],
    closed=True,
    label="poly_enclo",
)

poly_coil.mesh_options = {"lcar": lcar_coil, "physical_group": "poly_coil"}
coil = BluemiraFace(poly_coil)
coil.mesh_options = {"lcar": lcar_coil, "physical_group": "coil"}

# %% [markdown]
#
# create the enclosure (rectangular cross section) and set the mesh options

# %%
poly_enclo = tools.make_polygon(
    [[0, r_enclo, r_enclo, 0], [0, 0, 0, 0], [-r_enclo, -r_enclo, r_enclo, r_enclo]],
    closed=True,
    label="poly_enclo",
)

poly_enclo.mesh_options = {"lcar": lcar_enclo, "physical_group": "poly_enclo"}
enclosure = BluemiraFace([poly_enclo, poly_coil])
enclosure.mesh_options = {"lcar": lcar_enclo, "physical_group": "enclo"}

# %% [markdown]
#
# create the different components

# %%
c_universe = Component(name="universe")
c_enclo = PhysicalComponent(name="enclosure", shape=enclosure, parent=c_universe)
c_coil = PhysicalComponent(name="coil", shape=coil, parent=c_universe)

# %% [markdown]
#
# ## Mesh
#
# Create the mesh (by default, mesh is stored in the file Mesh.msh")

# %%
directory = get_bluemira_path("", subfolder="generated_data")
meshfiles = [Path(directory, p).as_posix() for p in ["Mesh.geo_unrolled", "Mesh.msh"]]

meshing.Mesh(meshfile=meshfiles)(c_universe, dim=2)

# %% [markdown]
#
# Convert the mesh in xdmf for reading in fenics.

# %%
msh_to_xdmf("Mesh.msh", dimensions=(0, 2), directory=directory)

mesh, boundaries, subdomains, labels = import_mesh(
    "Mesh",
    directory=directory,
    subdomains=True,
)
dolfin.plot(mesh)
plt.show()

# %% [markdown]
#
# ## Setup EM problem
#
# Finally, instantiate the em solver

# %%
em_solver = FemMagnetostatic2d(2)
em_solver.set_mesh(mesh, boundaries)

# %% [markdown]
#
# Define source term (coil current distribution) for the fem problem

# %%
Ic = 1e6
jc = Ic / coil.area
markers = [labels["coil"]]
functions = [jc]
jtot = ScalarSubFunc(functions, markers, subdomains)

# %% [markdown]
#
# plot the source term
#
# Note: depending on the geometric dimension of the coil, enclosure, and mesh
# characteristic length, the plot could be not so "explanatory".

# %%
f_space = dolfin.FunctionSpace(mesh, "DG", 0)
f = dolfin.Function(f_space)
f.interpolate(jtot)
dolfin.plot(f, title="Source term")
plt.show()

# %% [markdown]
#
# solve the em problem and calculate the magnetic field B

# %%
em_solver.define_g(jtot)
em_solver.solve()
em_solver.calculate_b()

# %% [markdown]
#
# Compare the obtained B with both the theoretical value
#
# 1) Along the z axis (analytical solution)

# %%
z_points_axis = np.linspace(0, r_enclo, 200)
r_points_axis = np.zeros(z_points_axis.shape)
Bz_axis = np.array(
    [em_solver.B(x) for x in np.array([r_points_axis, z_points_axis]).T]
).T[1]
B_teo = np.array([Bz_coil_axis(rc, 0, z, Ic) for z in z_points_axis])

fig, ax = plt.subplots()
ax.plot(z_points_axis, Bz_axis, label="B_calc")
ax.plot(z_points_axis, B_teo, label="B_teo")
plt.xlabel("r (m)")
plt.ylabel("B (T)")
plt.legend()
plt.show()

diff = Bz_axis - B_teo

fig, ax = plt.subplots()
ax.plot(z_points_axis, diff, label="B_calc - B_teo")
plt.xlabel("r (m)")
plt.ylabel("error (T)")
plt.legend()
plt.show()

# %% [markdown]
#
# 1) Along a radial path at z_offset (solution from green function)

# %%
z_offset = 40 * drc

points_x = np.linspace(0, r_enclo, 200)
points_z = np.zeros(z_points_axis.shape) + z_offset

g_psi, g_bx, g_bz = greens.greens_all(rc, 0, points_x, points_z)
g_psi *= Ic
g_bx *= Ic
g_bz *= Ic
B_fem = np.array([em_solver.B(x) for x in np.array([points_x, points_z]).T])
Bx_fem = B_fem.T[0]
Bz_fem = B_fem.T[1]

fig, ax = plt.subplots()
ax.plot(z_points_axis, Bx_fem, label="Bx_fem")
ax.plot(z_points_axis, g_bx, label="Green Bx")
plt.xlabel("r (m)")
plt.ylabel("Bx (T)")
plt.legend()
plt.show()

fig, ax = plt.subplots()
ax.plot(z_points_axis, Bz_fem, label="Bz_fem")
ax.plot(z_points_axis, g_bz, label="Green Bz")
plt.xlabel("r (m)")
plt.ylabel("Bz (T)")
plt.legend()
plt.show()

diff1 = Bx_fem - g_bx
diff2 = Bz_fem - g_bz

fig, ax = plt.subplots()
ax.plot(z_points_axis, diff1, label="B_calc - GreenBx")
ax.plot(z_points_axis, diff2, label="B_calc - GreenBz")
plt.legend()
plt.xlabel("r (m)")
plt.ylabel("error (T)")
plt.show()
